# take segmented data and specific input channels and combine into xarray for caliban
import xarray as xr
import numpy as np
from segmentation import helper_functions
import skimage.io as io
import os
import importlib
importlib.reload(helper_functions)

base_dir = "/Users/noahgreenwald/Documents/MIBI_Data/shirley/test_points/big_test/second_version/"
save_dir = base_dir + "caliban_v2"

if not os.path.isdir(save_dir):
    os.makedirs(save_dir)

# load segmentation generated by current version of deepcell, as well as points directory containing channels
segmentation_xr = xr.open_dataarray(base_dir + "/segmentation_output/20191214_Decidua_Caliban_V1_no6week_deepcell_output_pixel_processed_segmentation_labels.nc")

# specify what subset of points and channels will be used for segmentation
points = ["16_31762_16_21"]

save_dir = os.path.join(save_dir, points[0])

if not os.path.isdir(save_dir):
    os.makedirs(save_dir)

# load point data from previously created xarray
channel_xr = xr.open_dataarray(base_dir + "../denoised/Deepcell_Input_myeloid_int8.nc")

# subset segmentation and channels xr to only include desired points
channel_xr = channel_xr.loc[points, :, :, :]
segmentation_xr = segmentation_xr.loc[points, :, :, :]

# optionally subset data to include only a crop of the point, save modified coordinates for easy loading letter
channel_xr = channel_xr[:, :-1, -1, :]
segmentation_xr = segmentation_xr[:, -1, -1, :]
channel_xr.to_netcdf(os.path.join(save_dir, "channel_input.nc"))

# optionally add duplicates of the same channel for easier flipping between adjacent channels
channel_order = ["CD14", "H3", "CD56", "H3", "CD3", "H3", "VIM", "HLAG", "H3"]
channel_xr = helper_functions.reorder_xarray_channels(channel_order=channel_order, channel_xr=channel_xr)


# create new numpy array to hold selected channel data and segmentation labels
caliban_np = np.zeros((channel_xr.shape[:-1] + (channel_xr.shape[-1] + 1, )))

caliban_np[:, :, :, :-1] = channel_xr.values

caliban_np[:, :, :, -1:] = segmentation_xr.values

channel_names = np.append(channel_xr.channels.values, segmentation_xr.channels.values)

caliban_xr = xr.DataArray(caliban_np, coords=[channel_xr.points, range(caliban_np.shape[1]), range(caliban_np.shape[2]),
                                              channel_names], dims=["points", "rows", "cols", "channels"])

caliban_xr.to_netcdf(os.path.join(save_dir, "caliban_input.nc"), format="NETCDF3_64BIT")


# once data has been created, make overlay to assess accuracy
channels = xr.open_dataarray(os.path.join(save_dir, "channel_input.nc"))
mask = io.imread(os.path.join(save_dir "caliban_output.tiff"))

# plot list of supplied markers overlaid by segmentation mask to assess accuracy
overlay_channels = ["VIM", "HLAG"]
for channel in overlay_channels:
    chan_marker = channels.loc[channels.points.values[0], :, :, channel]
    helper_functions.plot_overlay(mask, plotting_tif=chan_marker,
                                  path=os.path.join(save_dir , "{}_overlay.tiff".format(channel)))
